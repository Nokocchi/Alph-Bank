TODO:
	Swagger, API, types:
Zod schema validation, or auto-generated types based on openapi spec? 
OpenAPI spec, generate API? 
Better swagger examples (like possible response codes)
Swagger @Tag annotation for all controllers
Swagger examples for all request body parameters
Check that SpringDocs.replace in starter works
Request body validators
Proper response entities with http codes

	Business logic:
Input validation on recipient IBAN when making payment - trim and validate IBAN format?
Scheduled should be behind toggle, optional
Figure out how to handle currencies. Automatic conversion, pick from list, can only pick currency of receiving account...? 
Created/Updated timestamp in db by using r2dbc auditing

	Documentation:
Each service should have sequence and component diagrams
Overall component diagram of all services

	Ideas:
Make tests that prove that MonetaryAmount is encoded correctly by the baseWebClientBuilder
Some kind of Oauth? Or at least a fake login with govId + countryCode?
Continuous streaming of data, like a stock ticker, but more relevant?
Caching?
Consider setting up Actuator/Spring Boot statistics in Grafana, maybe with some custom Prometheus metrics
Store all requests in central Elastic with traceid, customerId, etc.
- It should be possible to search for customerId, traceId, service name, date/time
- Maybe as a starter?
Feature toggles

----------------------------------------------------------------------------------------------------------------------------------

Test IBAN: DK4001110000784327

core-account-service:
- self: 8080
- postgres 5432
- adminer 5433

core-payment-service
- self: 8081
- postgres 5434
- adminer 5435

core-loan-service
- self: 8082
- postgres 5436
- adminer 5437
- rabbit 5672
- rabbit web 15672

core-customer-service
- self: 8083
- postgres 5438
- adminer 5439

----

Step 2:


Bank system
x Everything unique based on composite key (GovernmentId + Country Code)
x Core-account-service
	x Account number, balance
	x Internal, hidden endpoint for core-payment-service and core-loan-service to update balance
x Core-customer-service
	x Name, address, phone number
x Core-payment-service
	x Previous payments, future payment execution orders
	x Scheduled task to execute payment 
	x update account balance
x Core-loan-service
	x Previous granted loans, future loan payout orders 
	x Scheduled task to pay out loan
	x Once loan payout task executes, increase bank account balance
	x Once loan payout happens, send message by RabbitMQ to GovernmentReportingTransferService

----

Step 3:

GovernmentReportingTransferService
- Collects loan recipients
- Collects fraudulent loan applications
- uses Spring scheduling to send to governmental credit agency at midnight about all events in the last 24 hours. If it fails, resend next day along with new batch
- Backoff strategy if Service unavailable

----

Step 4:

Payment-service
- Based on PSD2
- Has RabbitMQ listener for sign-callbacks
- Instant, scheduled, recurring payments. Standing orders create payments, but are not payments themselves.
- Stores payments, standing orders in postgres
- How to schedule next payments?
- Each action is signed via signing-service
- Callback on RabbitMQ sends a payment execution order to BankSystem

Signing-service
- Sign request contains routing key for RabbitMQ
- Feature toggle decides whether signing goes well or not, but always automated
- Signed document is stored in mongodb

----

Step 5: 

GovernmentRequestService
- Compliance
- Api Key? 
- Needs token generated by external party, client credentials, correct scope
- Gathers information about accounts, customer information, etc. and returns it as XML

----

Step 6:

Credit worthiness assessment service
- Check the credit worthiness of a customer
- Use this to calculate how much money the customer can loan
- Very complex, so just assume we are calling external vendor, generate random data
- Stores information about loan limit and interest or similar - I don't know how this actually works
- Scheduled job that deletes data after 5 years

Fraud service
- Check if customer or loan application is fraudulent 
- Very complex, assume we are calling external vendor.
- Always return true
- Implement extra check with feature toggle, will now return false for all customers
- If fraudulent activity detected, send message to GovernmentReportingTransferService

----

Step 7:

Loan application service
- Uses some external credit worthiness assessment service to find loan limit and interest (?)
- Takes desired loan amount as input
- Checks fraud-service if fraudulent
- Show error page if credit worthiness not high enough or application fraudulent.
- If ok, send loan application order to bank system
- Has postgres database with status about loan. In progress, manual inspection, action required, approved but waiting execution, etc.

----

Step 8:

Frontend
x See your profile, settings (core-customer-service)
x See your accounts, their balances etc (core-account-service)
x Load individual account (core-payment-service, core-loan-service merged data)
- See all ongoing loan applications and status
- Make payment, choose account from list
- I18n, language selector?

----

Step 9:

Know-your-customer service
- Questions in one table, Answers in another
- Unique key on Answer table (QuestionId + CustomerId)
- Questions can have a "staleAfter" field that denotes when an answer to this question is no longer valid
- Answers should have createdDate, updatedDate
- Every time customer logs in, questions table is checked and if any mandatory question are unanswered, show KYC page
- Assume no complex/multilayered logic / flows for when questions are mandatory. Mandatoryness is always absolute and defined per question.
- If KYC service says that everything looks good, continue to profile
















