Mono.fromCallable(() -> {
    // blocking operation
}).subscribeOn(Schedulers.boundedElastic());


{
  "locale": "sv_SE",
  "governmentId": "191212121212",
  "firstName": "Kalle",
  "lastName": "Jansson",
  "phoneNumber": "0737373737",
  "address": {
    "streetAddress": "Djuss street",
    "city": "Djussity",
    "country": "Djusland"
  }
}

{
  "customerId": "7373f9fd-f53d-4c6f-8ad0-7898177118b9",
  "accountId": "e60a0086-9533-44c4-9410-ec82bff7940e",
  "remittanceAmount": {
    "amount": 99.96,
    "currency": "SEK"
  },
  "messageToSelf": "Payment!",
  "recipientIban": "SE5311100000000000685238",
  "getExecutionDateTime": "2024-03-30T13:23:13.659Z"
}

TODO:
Fix the starter with the correct build.gradle and figure out how to publish it
slf4j logging?
Clean up database dependencies and properties.
Created/Updated timestamp
Request body validators
Proper response entities with http codes
Better swagger examples (like possible response codes)
Swagger @Tag annotation for all controllers
Swagger examples for all request body parameters
Make payment: Check that currency matches account? Or convert? 
MoneyModule and swagger SpringDocs.replace in starter?

core-account-service:
- self: 8080
- postgres 5432
- adminer 5433

core-payment-service
- self: 8081
- postgres 5434
- adminer 5435

core-loan-service
- self: 8082
- postgres 5436
- adminer 5437
- rabbit 5672
- rabbit web 15672

core-customer-service
- self: 8083
- postgres 5438
- adminer 5439


Step 1:

Auth-service
- Sign up
- Oauth2?
- Generate JWT
- GovernmentId + CountryCode + password instead of BankId
- Grant permissions based on scope
- Allow external parties access via client credentials and scope, etc.

----

Step 2:


Bank system
x Everything unique based on composite key (GovernmentId + Country Code)
x Core-account-service
	x Account number, balance
	x Internal, hidden endpoint for core-payment-service and core-loan-service to update balance
x Core-customer-service
	x Name, address, phone number
x Core-payment-service
	x Previous payments, future payment execution orders
	x Scheduled task to execute payment 
	x update account balance
- Core-loan-service
	x Previous granted loans, future loan payout orders 
	x Scheduled task to pay out loan
	x Once loan payout task executes, increase bank account balance
	x Once loan payout happens, send message by RabbitMQ to GovernmentReportingTransferService

----

Step 3:

GovernmentReportingTransferService
- Collects loan recipients
- Collects fraudulent loan applications
- uses Spring scheduling to send to governmental credit agency at midnight about all events in the last 24 hours. If it fails, resend next day along with new batch
- Backoff strategy if Service unavailable

----

Step 4:

Payment-service
- Based on PSD2
- Has RabbitMQ listener for sign-callbacks
- Instant, scheduled, recurring payments. Standing orders create payments, but are not payments themselves.
- Stores payments, standing orders in postgres
- How to schedule next payments?
- Each action is signed via signing-service
- Callback on RabbitMQ sends a payment execution order to BankSystem

Signing-service
- Sign request contains routing key for RabbitMQ
- Feature toggle decides whether signing goes well or not, but always automated
- Signed document is stored in mongodb

----

Step 5: 

GovernmentRequestService
- Compliance
- Api Key? 
- Needs token generated by external party, client credentials, correct scope
- Gathers information about accounts, customer information, etc. and returns it as XML

----

Step 6:

Credit worthiness assessment service
- Check the credit worthiness of a customer
- Use this to calculate how much money the customer can loan
- Very complex, so just assume we are calling external vendor, generate random data
- Stores information about loan limit and interest or similar - I don't know how this actually works
- Scheduled job that deletes data after 5 years

Fraud service
- Check if customer or loan application is fraudulent 
- Very complex, assume we are calling external vendor.
- Always return true
- Implement extra check with feature toggle, will now return false for all customers
- If fraudulent activity detected, send message to GovernmentReportingTransferService

----

Step 7:

Loan application service
- Uses some external credit worthiness assessment service to find loan limit and interest (?)
- Takes desired loan amount as input
- Checks fraud-service if fraudulent
- Show error page if credit worthiness not high enough or application fraudulent.
- If ok, send loan application order to bank system
- Has postgres database with status about loan. In progress, manual inspection, action required, approved but waiting execution, etc.

----

Step 8:

Frontend
- See your profile, settings (core-customer-service)
- See your accounts, their balances etc (core-account-service)
- Load individual account (core-payment-service, core-loan-service merged data)
- See all ongoing loan applications and status
- Make payment, choose account from list
- I18n, language selector?

----

Step 9:

Know-your-customer service
- Questions in one table, Answers in another
- Unique key on Answer table (QuestionId + CustomerId)
- Questions can have a "staleAfter" field that denotes when an answer to this question is no longer valid
- Answers should have createdDate, updatedDate
- Every time customer logs in, questions table is checked and if any mandatory question are unanswered, show KYC page
- Assume no complex/multilayered logic / flows for when questions are mandatory. Mandatoryness is always absolute and defined per question.
- If KYC service says that everything looks good, continue to profile

----

Figure out:

How do services call each other? 
Centralized s2s granter where a token request, signed by service's own private key, can be exchanged for a valid token with proper permissions if the private key matches the public key

Extra ideas:

Store all requests in central Elastic with traceid, customerId, etc.
- It should be possible to search for customerId, traceId, service name, date/time
- Maybe as a starter?

Each service should have sequence and component diagrams

Caching?

Consider setting up Actuator/Spring Boot statistics in Grafana, maybe with some custom Prometheus metrics














